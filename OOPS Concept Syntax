1)Collections- Group of related data items
List-List<string> capital= new List<string>
Dictionary-Dictionary<string,string> capital= new Dictionary<string,string>
2)Interface - Contract in C# which tells what method must be implement and does not give the actually code
interface Ishape
{
void Draw();
}
public class Square : IShape
{
    public void Draw()
    {
        Console.WriteLine("Drawing Square");
    }
}
3)Abstraction Syntax- Hiding the details and showing the essentials stuffs
public abstract class Shape
{
public abstract void Draw();
public void Display()
{
Console.WriteLine("This is a shape")
}

}
public class Circle:Shape
{
public override void Draw()
{
 Console.WriteLine("Drawing Circle");
}

4) Polymorphism- Many forms
using the same method name but it does different things depending on the object or input
#Compile time Polymorphism(Method Overloading)-same Method name but different parameters
Syntax
using System;
class Calculator
{
public int add(int a,int b)
{
return a+b;
}
public double add(double a,double b)
{
return a+b;
}
}
class Program
{
public  static void Main()
{
calculator c= new calculator;
Console.WriteLine(c.Add(5,10));
Console.WriteLine(c.Add(5.5,10.5));
}
}
#Runtime Polymorphism-Base class method is redefined in the derived class.
using System;

class Animal
{
    public virtual void Speak()
    {
        Console.WriteLine("Animal makes a sound");
    }
}

class Dog : Animal
{
    public override void Speak()
    {
        Console.WriteLine("Dog barks");
    }
}

class Cat : Animal
{
    public override void Speak()
    {
        Console.WriteLine("Cat meows");
    }
}

class Program
{
    static void Main()
    {
        Animal a;

        a = new Dog();
        a.Speak();   // Dog barks

        a = new Cat();
        a.Speak();   // Cat meows
    }
}
5) Inheritance - allows one class to acquire the members of another class
Types of Inheritance:
# Single Inheritance -One base class → One derived class.
class A { }
class B : A { }
# Multilevel Inheritance -Inheritance across multiple levels (grandparent → parent → child).
class A { }
class B : A { }
class C : B { }
#Hierarchical Inheritance -One base class → multiple derived classes.
class A { }
class B : A { }
class C : A { }
6) Encapsulation- hiding the internal details of the class and exposing what is necessary through public method or properties.
Encapsulation:
public class HelloWorld
{
private string name;
public string getName()
{
return name;
}
public string setName()
{
this.name=Name;
}
public static void Main(string[]args)
{
HelloWorld HP=HelloWorld;
HP.setName("Ahnay");
Console.WriteLine(HP.getName);
}
}
7)Constructors-special method that is automatically called when an object of a class is created.
It has the same name as the class name
It has no return type
Syntax
class ClassName
{
public ClassName
{
}
}
Types of Constructors in C#
1. Default Constructor-Takes no parameters.
class Student
{
    public Student()
    {
        Console.WriteLine("Default constructor called");
    }
}
2. Parameterized Constructor-Accepts parameters to initialize fields.

class Student
{
    public string Name;
    public Student(string name)
    {
        Name = name;
    }
}

3. Copy Constructor-Creates a new object by copying values from another object.

class Student
{
    public string Name;
    public Student(string name)
    {
        Name = name;
    }

    // Copy constructor
    public Student(Student s)
    {
        Name = s.Name;
    }
}

4. Static Constructor-Used to initialize static fields.

Runs only once when the class is first used.

No parameters allowed.

class Student
{
    static Student()
    {
        Console.WriteLine("Static constructor called once");
    }
}

5. Private Constructor-Used to restrict object creation outside the class.

Commonly used in Singleton Design Pattern.

class Student
{
    private Student() { }
}
